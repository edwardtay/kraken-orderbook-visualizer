<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kraken Orderbook Visualizer</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            min-height: 100vh;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            text-align: center;
        }
        .header h1 { font-size: 28px; margin-bottom: 5px; }
        .header p { opacity: 0.9; font-size: 14px; }
        .header .sdk-badge {
            display: inline-block;
            background: rgba(255,255,255,0.2);
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            margin-top: 8px;
        }

        .controls {
            display: flex; gap: 15px; padding: 15px 20px;
            background: #1a1a1a; border-bottom: 1px solid #333;
            flex-wrap: wrap; align-items: center;
        }
        .control-group { display: flex; flex-direction: column; gap: 4px; }
        .control-group label { font-size: 11px; text-transform: uppercase; opacity: 0.7; }
        .control-group select, .control-group input {
            padding: 8px 12px; border-radius: 6px; border: 1px solid #444;
            background: #2a2a2a; color: #e0e0e0; font-size: 14px;
        }

        .status {
            padding: 6px 12px; border-radius: 12px; font-size: 13px;
            display: flex; align-items: center; gap: 6px;
        }
        .status.connected { background: rgba(39,174,96,0.2); color: #27ae60; }
        .status.disconnected { background: rgba(231,76,60,0.2); color: #e74c3c; }
        .status.connecting { background: rgba(241,196,15,0.2); color: #f1c40f; }

        .main { padding: 20px; max-width: 1400px; margin: 0 auto; }

        .stats {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px; margin-bottom: 20px;
        }
        .stat-card {
            background: #1e1e1e; padding: 15px; border-radius: 8px;
            border-left: 3px solid #667eea;
        }
        .stat-card .label { font-size: 12px; opacity: 0.7; margin-bottom: 5px; }
        .stat-card .value { font-size: 24px; font-weight: 600; }
        .stat-card.spread { border-left-color: #f39c12; }
        .stat-card.bid { border-left-color: #27ae60; }
        .stat-card.ask { border-left-color: #e74c3c; }

        .orderbook-container {
            display: grid; grid-template-columns: 1fr 1fr; gap: 20px;
        }
        .orderbook-side {
            background: #1e1e1e; border-radius: 8px; padding: 15px;
        }
        .orderbook-side h3 {
            margin-bottom: 15px; font-size: 16px;
            display: flex; align-items: center; gap: 8px;
        }
        .bids h3 { color: #27ae60; }
        .asks h3 { color: #e74c3c; }

        .level {
            display: grid; grid-template-columns: 1fr 1fr 60px;
            padding: 6px 0; border-bottom: 1px solid #2a2a2a;
            font-size: 13px; position: relative;
        }
        .level .bar {
            position: absolute; top: 0; bottom: 0; opacity: 0.15;
            transition: width 0.3s;
        }
        .bids .bar { background: #27ae60; right: 0; }
        .asks .bar { background: #e74c3c; left: 0; }
        .level .price { font-weight: 600; z-index: 1; }
        .level .volume { text-align: right; z-index: 1; }
        .level .percent { text-align: right; opacity: 0.6; z-index: 1; }

        .level-header {
            display: grid; grid-template-columns: 1fr 1fr 60px;
            padding: 8px 0; border-bottom: 2px solid #333;
            font-size: 11px; text-transform: uppercase; opacity: 0.6;
        }

        .update-count {
            font-size: 12px; opacity: 0.6; margin-left: auto;
        }

        .source-info {
            background: #1e1e1e;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            font-size: 13px;
        }
        .source-info h4 { margin-bottom: 10px; color: #667eea; }
        .source-info code {
            background: #2a2a2a;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
        }

        @media (max-width: 768px) {
            .orderbook-container { grid-template-columns: 1fr; }
            .controls { flex-direction: column; }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Kraken Orderbook Visualizer</h1>
        <p>Real-time orderbook visualization with time travel</p>
        <div class="sdk-badge">Powered by kraken-ws-sdk v0.2 from crates.io</div>
    </div>

    <div class="controls">
        <div class="control-group">
            <label>Symbol</label>
            <select id="symbol">
                <option value="XBT/USD">BTC/USD</option>
                <option value="ETH/USD">ETH/USD</option>
                <option value="SOL/USD">SOL/USD</option>
                <option value="XRP/USD">XRP/USD</option>
                <option value="DOGE/USD">DOGE/USD</option>
            </select>
        </div>
        <div class="control-group">
            <label>Depth</label>
            <select id="depth">
                <option value="10" selected>10 levels</option>
                <option value="25">25 levels</option>
            </select>
        </div>
        <div class="control-group">
            <label>Source</label>
            <select id="source">
                <option value="backend">Backend (kraken-ws-sdk)</option>
                <option value="direct">Direct Kraken WS</option>
            </select>
        </div>
        <div id="status" class="status connecting">
            <span class="dot">●</span>
            <span class="text">Connecting...</span>
        </div>
        <div class="update-count" id="updateCount">Updates: 0</div>
    </div>

    <div class="main">
        <div class="stats">
            <div class="stat-card">
                <div class="label">Mid Price</div>
                <div class="value" id="midPrice">--</div>
            </div>
            <div class="stat-card spread">
                <div class="label">Spread</div>
                <div class="value" id="spread">--</div>
            </div>
            <div class="stat-card bid">
                <div class="label">Best Bid</div>
                <div class="value" id="bestBid">--</div>
            </div>
            <div class="stat-card ask">
                <div class="label">Best Ask</div>
                <div class="value" id="bestAsk">--</div>
            </div>
        </div>

        <div class="orderbook-container">
            <div class="orderbook-side bids">
                <h3><span>Bids (Buy Orders)</span></h3>
                <div class="level-header">
                    <div>Price (USD)</div>
                    <div style="text-align:right">Volume</div>
                    <div style="text-align:right">%</div>
                </div>
                <div id="bidsContainer"></div>
            </div>
            <div class="orderbook-side asks">
                <h3><span>Asks (Sell Orders)</span></h3>
                <div class="level-header">
                    <div>Price (USD)</div>
                    <div style="text-align:right">Volume</div>
                    <div style="text-align:right">%</div>
                </div>
                <div id="asksContainer"></div>
            </div>
        </div>

        <div class="source-info">
            <h4>Architecture</h4>
            <p>This visualizer uses <code>kraken-ws-sdk v0.2</code> from <a href="https://crates.io/crates/kraken-ws-sdk" style="color:#667eea">crates.io</a></p>
            <p style="margin-top:8px">Backend: Rust (Warp + kraken-ws-sdk) → Frontend: HTML/JS</p>
            <p style="margin-top:8px">Backend API: <code>http://localhost:3033</code> | WebSocket: <code>ws://localhost:3033/ws/orderbook/:symbol</code></p>
        </div>
    </div>

    <script>
        // State
        let ws = null;
        let orderbook = { bids: {}, asks: {} };
        let updateCount = 0;
        let currentSymbol = 'XBT/USD';
        let currentDepth = 10;
        let currentSource = 'backend';

        // DOM Elements
        const symbolSelect = document.getElementById('symbol');
        const depthSelect = document.getElementById('depth');
        const sourceSelect = document.getElementById('source');
        const statusEl = document.getElementById('status');
        const updateCountEl = document.getElementById('updateCount');
        const midPriceEl = document.getElementById('midPrice');
        const spreadEl = document.getElementById('spread');
        const bestBidEl = document.getElementById('bestBid');
        const bestAskEl = document.getElementById('bestAsk');
        const bidsContainer = document.getElementById('bidsContainer');
        const asksContainer = document.getElementById('asksContainer');

        // Format number
        function formatPrice(price) {
            const p = parseFloat(price);
            if (p >= 1000) return p.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            if (p >= 1) return p.toFixed(4);
            return p.toFixed(6);
        }

        function formatVolume(vol) {
            const v = parseFloat(vol);
            if (v >= 1000) return v.toFixed(0);
            if (v >= 1) return v.toFixed(2);
            return v.toFixed(4);
        }

        // Update status
        function setStatus(state, text) {
            statusEl.className = 'status ' + state;
            statusEl.querySelector('.text').textContent = text;
        }

        // Render orderbook
        function renderOrderbook() {
            // Convert to sorted arrays
            const bids = Object.entries(orderbook.bids)
                .map(([price, volume]) => ({ price: parseFloat(price), volume: parseFloat(volume) }))
                .filter(b => b.volume > 0)
                .sort((a, b) => b.price - a.price)
                .slice(0, currentDepth);

            const asks = Object.entries(orderbook.asks)
                .map(([price, volume]) => ({ price: parseFloat(price), volume: parseFloat(volume) }))
                .filter(a => a.volume > 0)
                .sort((a, b) => a.price - b.price)
                .slice(0, currentDepth);

            if (bids.length === 0 && asks.length === 0) return;

            // Calculate max volume for bar width
            const maxVolume = Math.max(
                ...bids.map(b => b.volume),
                ...asks.map(a => a.volume),
                0.001
            );

            // Calculate totals
            let bidTotal = bids.reduce((sum, b) => sum + b.volume, 0);
            let askTotal = asks.reduce((sum, a) => sum + a.volume, 0);

            // Render bids
            bidsContainer.innerHTML = bids.map(bid => {
                const pct = (bid.volume / bidTotal * 100).toFixed(1);
                const barWidth = (bid.volume / maxVolume * 100).toFixed(0);
                return `
                    <div class="level">
                        <div class="bar" style="width:${barWidth}%"></div>
                        <div class="price">$${formatPrice(bid.price)}</div>
                        <div class="volume">${formatVolume(bid.volume)}</div>
                        <div class="percent">${pct}%</div>
                    </div>
                `;
            }).join('');

            // Render asks
            asksContainer.innerHTML = asks.map(ask => {
                const pct = (ask.volume / askTotal * 100).toFixed(1);
                const barWidth = (ask.volume / maxVolume * 100).toFixed(0);
                return `
                    <div class="level">
                        <div class="bar" style="width:${barWidth}%"></div>
                        <div class="price">$${formatPrice(ask.price)}</div>
                        <div class="volume">${formatVolume(ask.volume)}</div>
                        <div class="percent">${pct}%</div>
                    </div>
                `;
            }).join('');

            // Update stats
            if (bids.length > 0 && asks.length > 0) {
                const bestBid = bids[0].price;
                const bestAsk = asks[0].price;
                const mid = (bestBid + bestAsk) / 2;
                const spread = bestAsk - bestBid;

                midPriceEl.textContent = '$' + formatPrice(mid);
                spreadEl.textContent = '$' + formatPrice(spread);
                bestBidEl.textContent = '$' + formatPrice(bestBid);
                bestAskEl.textContent = '$' + formatPrice(bestAsk);
            }

            updateCountEl.textContent = `Updates: ${updateCount}`;
        }

        // Process backend message
        function processBackendMessage(data) {
            if (data.type === 'snapshot' && data.data) {
                orderbook = { bids: {}, asks: {} };

                if (data.data.bids) {
                    data.data.bids.forEach(level => {
                        orderbook.bids[level.price] = level.volume;
                    });
                }
                if (data.data.asks) {
                    data.data.asks.forEach(level => {
                        orderbook.asks[level.price] = level.volume;
                    });
                }

                updateCount++;
                renderOrderbook();
            }
        }

        // Process Kraken direct message
        function processKrakenMessage(data) {
            if (!Array.isArray(data)) {
                if (data.event === 'subscriptionStatus' && data.status === 'subscribed') {
                    console.log('Subscribed to:', data.pair);
                }
                return;
            }

            const channelData = data[1];
            const channelName = data[2];

            if (!channelName || !channelName.startsWith('book')) return;

            // Snapshot
            if (channelData.as && channelData.bs) {
                orderbook = { bids: {}, asks: {} };
                channelData.bs.forEach(([price, volume]) => {
                    orderbook.bids[price] = volume;
                });
                channelData.as.forEach(([price, volume]) => {
                    orderbook.asks[price] = volume;
                });
                updateCount++;
                renderOrderbook();
                return;
            }

            // Updates
            if (channelData.a) {
                channelData.a.forEach(([price, volume]) => {
                    if (parseFloat(volume) === 0) {
                        delete orderbook.asks[price];
                    } else {
                        orderbook.asks[price] = volume;
                    }
                });
            }
            if (channelData.b) {
                channelData.b.forEach(([price, volume]) => {
                    if (parseFloat(volume) === 0) {
                        delete orderbook.bids[price];
                    } else {
                        orderbook.bids[price] = volume;
                    }
                });
            }

            updateCount++;
            renderOrderbook();
        }

        // Connect to backend WebSocket
        function connectToBackend() {
            if (ws) ws.close();

            orderbook = { bids: {}, asks: {} };
            updateCount = 0;
            setStatus('connecting', 'Connecting to backend...');

            const wsUrl = `ws://localhost:3033/ws/orderbook/${encodeURIComponent(currentSymbol)}`;

            try {
                ws = new WebSocket(wsUrl);

                ws.onopen = () => {
                    console.log('Connected to backend');
                    setStatus('connected', 'Backend (kraken-ws-sdk)');
                };

                ws.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        processBackendMessage(data);
                    } catch (e) {
                        console.error('Parse error:', e);
                    }
                };

                ws.onerror = (err) => {
                    console.error('Backend WebSocket error:', err);
                    setStatus('disconnected', 'Backend error - try Direct');
                };

                ws.onclose = () => {
                    setStatus('disconnected', 'Disconnected');
                };
            } catch (e) {
                setStatus('disconnected', 'Connection failed');
            }
        }

        // Connect directly to Kraken
        function connectToKraken() {
            if (ws) ws.close();

            orderbook = { bids: {}, asks: {} };
            updateCount = 0;
            setStatus('connecting', 'Connecting to Kraken...');

            ws = new WebSocket('wss://ws.kraken.com');

            ws.onopen = () => {
                console.log('Connected to Kraken');
                setStatus('connected', 'Direct Kraken WS');

                const subscribeMsg = {
                    event: 'subscribe',
                    pair: [currentSymbol],
                    subscription: { name: 'book', depth: currentDepth }
                };
                ws.send(JSON.stringify(subscribeMsg));
            };

            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    processKrakenMessage(data);
                } catch (e) {
                    console.error('Parse error:', e);
                }
            };

            ws.onerror = (err) => {
                console.error('Kraken WebSocket error:', err);
                setStatus('disconnected', 'Connection Error');
            };

            ws.onclose = () => {
                setStatus('disconnected', 'Disconnected');
                setTimeout(() => {
                    if (currentSource === 'direct') connectToKraken();
                }, 3000);
            };
        }

        // Connect based on source
        function connect() {
            if (currentSource === 'backend') {
                connectToBackend();
            } else {
                connectToKraken();
            }
        }

        // Event listeners
        symbolSelect.addEventListener('change', () => {
            currentSymbol = symbolSelect.value;
            connect();
        });

        depthSelect.addEventListener('change', () => {
            currentDepth = parseInt(depthSelect.value);
            connect();
        });

        sourceSelect.addEventListener('change', () => {
            currentSource = sourceSelect.value;
            connect();
        });

        // Initialize
        connect();
    </script>
</body>
</html>
